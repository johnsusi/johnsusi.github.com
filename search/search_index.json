{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Software development is more than just writing code\u2014it's about solving hard problems, understanding trade-offs, and pushing the limits of performance. This blog is for developers who thrive on complexity, those who enjoy dissecting intricate systems, and those who seek clarity in the chaos of software architecture.</p> <p>I write about building systems in C++, C#, Go. Exploring different ways to solve problems like Domain-Driven Design, the Actor model as well as the occational dive into things like Terraform and Kubernetes.</p> <ul> <li> <p> Mobile development</p> <p> Getting started</p> </li> <li> <p> The pragmatic progammer</p> <p> Reference</p> </li> <li> <p> Made to measure</p> <p>Change the colors, fonts, language, icons, logo and more with a few lines</p> <p> Customization</p> </li> <li> <p> Benchmarking IoT Workloads</p> <p> Read the series</p> </li> </ul>"},{"location":"strategy-pattern/","title":"Strategy pattern","text":"<p>The Strategy pattern is a behavioral design pattern that enables an object to dynamically change its behavior at runtime by encapsulating different algorithms within interchangeable strategy objects.</p>"},{"location":"strategy-pattern/#problem","title":"Problem","text":"<p>In software development, we often encounter situations where we need to implement different algorithms or behaviors that can be used interchangeably. However, hardcoding these behaviors within the main object can lead to code duplication and make the codebase difficult to maintain and extend.</p>"},{"location":"strategy-pattern/#solution","title":"Solution","text":"<p>The Strategy pattern suggests encapsulating each algorithm or behavior within its own strategy object. These strategy objects can then be passed to the main object, allowing it to dynamically change its behavior at runtime.</p>"},{"location":"strategy-pattern/#structure","title":"Structure","text":"<p>The Strategy pattern consists of the following components:</p> <ul> <li> <p>Context: The main object that interacts with the strategy objects. It maintains a reference to the current strategy object and delegates the execution of the algorithm to it.</p> </li> <li> <p>Strategy: The interface or base class that defines the common methods that all strategy objects must implement.</p> </li> <li> <p>Concrete Strategies: The concrete implementations of the strategy interface. Each concrete strategy encapsulates a specific algorithm or behavior.</p> </li> </ul>"},{"location":"strategy-pattern/#example","title":"Example","text":"<p>Let's consider an example where we have a <code>SortingContext</code> class that needs to sort a collection of elements. Instead of hardcoding the sorting algorithm within the <code>SortingContext</code> class, we can use the Strategy pattern to encapsulate different sorting algorithms within separate strategy objects.</p> <pre><code>class SortingStrategy {\npublic:\n    virtual void sort(std::vector&lt;int&gt;&amp; elements) const = 0;\n};\n\nclass BubbleSortStrategy : public SortingStrategy {\npublic:\n    void sort(std::vector&lt;int&gt;&amp; elements) const override {\n        // Implementation of bubble sort algorithm\n    }\n};\n\nclass QuickSortStrategy : public SortingStrategy {\npublic:\n    void sort(std::vector&lt;int&gt;&amp; elements) const override {\n        // Implementation of quick sort algorithm\n    }\n};\n\nclass SortingContext {\nprivate:\n    const SortingStrategy* strategy;\n\npublic:\n    SortingContext(const SortingStrategy* strategy)\n        : strategy(strategy) {}\n\n    void setStrategy(const SortingStrategy* strategy) {\n        this-&gt;strategy = strategy;\n    }\n\n    void sort(std::vector&lt;int&gt;&amp; elements) const {\n        strategy-&gt;sort(elements);\n    }\n};\n</code></pre> <p>In the above example, the <code>SortingContext</code> class acts as the context, while the <code>SortingStrategy</code> interface represents the strategy. The <code>BubbleSortStrategy</code> and <code>QuickSortStrategy</code> classes are concrete strategies that encapsulate the bubble sort and quick sort algorithms, respectively.</p> <p>By using the Strategy pattern, we can easily switch between different sorting algorithms without modifying the <code>SortingContext</code> class. This promotes code reusability, maintainability, and extensibility.</p>"},{"location":"strategy-pattern/#conclusion","title":"Conclusion","text":"<p>The Strategy pattern provides a flexible way to encapsulate different algorithms or behaviors within interchangeable strategy objects. By decoupling the main object from specific implementations, it allows for runtime behavior changes and promotes code reusability and maintainability.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2025/01/26/setting-up-a-new-c-project/","title":"Setting Up a Modern C++ Project with CMake","text":"<p>In this blog post, I'll walk you through setting up a new C++ project using CMake. We'll explore folder structure, dependency management, and how to share your project with others. I will use my little game project as an example.</p>","tags":["c++","make","cmake"]},{"location":"blog/2025/01/26/setting-up-a-new-c-project/#project-structure","title":"Project Structure","text":"<p>The folder structure for the project is organized as follows:</p> <pre><code>project-root/\n\u251c\u2500\u2500 etc/\n\u2502   \u2514\u2500\u2500 cmake\n\u2502       \u2514\u2500\u2500 toolchain.cmake\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500  engine\n\u2502   \u2502   \u251c\u2500\u2500  CMakeLists.txt\n\u2502   \u2502   \u251c\u2500\u2500  video.cpp\n\u2502   \u2502   \u251c\u2500\u2500  video.h\n\u2502   \u2502   \u2514\u2500\u2500 ... \n\u2502   \u2514\u2500\u2500 game\n\u2502       \u251c\u2500\u2500 CMakeLists.txt\n\u2502       \u251c\u2500\u2500 main.cpp\n\u2502       \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 test/\n\u2502   \u251c\u2500\u2500 CMakeLists.txt\n\u2502   \u251c\u2500\u2500 engine_tests.cpp\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 .clang-format\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 CMakePresets.json\n\u251c\u2500\u2500 Makefile\n\u2514\u2500\u2500 vcpkg.json\n</code></pre>","tags":["c++","make","cmake"]},{"location":"blog/2025/01/26/setting-up-a-new-c-project/#root-cmakeliststxt","title":"Root <code>CMakeLists.txt</code>","text":"<p>The root <code>CMakeLists.txt</code> declares the project and manages dependencies:</p> <pre><code>cmake_minimum_required(VERSION 3.28.3)\nproject(MyLittleGame\n    DESCRIPTION \"Just a little game\"\n    VERSION 1.0\n    LANGUAGES CXX\n)\n\nfind_package(assimp 5.4 CONFIG REQUIRED)\nfind_package(Bullet 3 CONFIG REQUIRED)\nfind_package(GLEW 2.2 CONFIG REQUIRED)\nfind_package(glm 1.0 CONFIG REQUIRED)\nfind_package(SDL3 3.2 CONFIG REQUIRED)\n\nadd_subdirectory(src/engine)\nadd_subdirectory(src/game)\n\ninclude(CTest)\nif(ENABLE_TESTING AND CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)\n    add_subdirectory(test)\nendif()\n</code></pre>","tags":["c++","make","cmake"]},{"location":"blog/2025/01/26/setting-up-a-new-c-project/#source-folder","title":"Source Folder","text":"<p>The <code>src</code> folder contains the game library and executable. Here's an example <code>CMakeLists.txt</code>:</p> <pre><code>add_library(engine)\n\ntarget_compile_features(engine\n    PUBLIC\n        cxx_std_20\n)\n\ntarget_sources(engine\n    PRIVATE\n        video.cpp\n    PUBLIC\n        FILE_SET HEADERS\n        BASE_DIRS ..\n        FILES\n            video.h\n)\n\ntarget_link_libraries(engine\n    PRIVATE\n        assimp::assimp\n        LinearMath\n        Bullet3Common\n        BulletInverseDynamics\n        BulletCollision\n        BulletDynamics\n        BulletSoftBody\n        GLEW::GLEW\n        glm::glm\n        SDL3::SDL3\n)\n</code></pre> <p>And another example of consuming that library</p> <pre><code>add_executable(game)\n\ntarget_compile_features(game\n    PUBLIC\n        cxx_std_20\n)\n\ntarget_sources(game\n    PRIVATE\n        main.cpp\n)\n\ntarget_link_libraries(game\n    PRIVATE\n        engine\n)\n</code></pre>","tags":["c++","make","cmake"]},{"location":"blog/2025/01/26/setting-up-a-new-c-project/#test-folder","title":"Test Folder","text":"<p>The <code>test</code> folder is only included if testing is enabled. Example <code>CMakeLists.txt</code>:</p> <pre><code>add_executable(UnitTests)\n\ntarget_sources(UnitTests\n    PRIVATE\n        engine_tests.cpp\n)\n\ntarget_link_libraries(UnitTests\n    PRIVATE\n        engine\n)\n</code></pre>","tags":["c++","make","cmake"]},{"location":"blog/2025/01/26/setting-up-a-new-c-project/#dependency-management","title":"Dependency Management","text":"","tags":["c++","make","cmake"]},{"location":"blog/2025/01/26/setting-up-a-new-c-project/#installing-vcpkg","title":"Installing Vcpkg","text":"<p>Vcpkg is installed either in a global folder like <code>$HOME/vcpkg</code> or as a git submodule <code>git submodule add https://github.com/microsoft/vcpkg.git</code>. Use the <code>VCPKG_ROOT</code> environment variable to point to the global vcpkg folder.</p>","tags":["c++","make","cmake"]},{"location":"blog/2025/01/26/setting-up-a-new-c-project/#using-vcpkg-in-manifest-mode","title":"Using Vcpkg in Manifest Mode","text":"<p>Dependencies are declared using a <code>vcpkg.json</code> manifest file:</p> <pre><code>{\n    \"$schema\": \"https://raw.githubusercontent.com/microsoft/vcpkg-tool/main/docs/vcpkg.schema.json\",\n    \"dependencies\": [\n        {\n            \"name\": \"assimp\"\n        },\n        {\n            \"name\": \"bullet3\"\n        },\n        {\n            \"name\": \"glew\"\n        },\n        {\n            \"name\": \"glm\"\n        },\n        {\n            \"name\": \"sdl3\"\n        }\n    ]\n}\n</code></pre> <p>To simplify detection if the global or local option is used, a custom toolchain file checks for <code>VCPKG_ROOT</code>:</p> <pre><code>if(DEFINED ENV{VCPKG_ROOT})\n    include(\"$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake\")\nelseif(EXISTS \"${CMAKE_SOURCE_DIR}/vcpkg/scripts/buildsystems/vcpkg.cmake\")\n    include(\"${CMAKE_SOURCE_DIR}/vcpkg/scripts/buildsystems/vcpkg.cmake\")\nelse()\n    message(FATAL_ERROR \"Vcpkg not found\")\nendif()\n</code></pre> <p>I wonder if <code>FetchContent_Populate</code> could be used here as well?</p>","tags":["c++","make","cmake"]},{"location":"blog/2025/01/26/setting-up-a-new-c-project/#extras","title":"Extras","text":"","tags":["c++","make","cmake"]},{"location":"blog/2025/01/26/setting-up-a-new-c-project/#use-cmake-presets-to-simplify-setup","title":"Use CMake presets to simplify setup","text":"<p>Defaults are usually fine but if you need to build with different compilers or set different options, create a <code>CMakePresets.json</code> file.</p> <pre><code>{\n    \"$schema\": \"https://cmake.org/cmake/help/latest/_downloads/3e2d73bff478d88a7de0de736ba5e361/schema.json\",\n    \"version\": 8,\n    \"configurePresets\": [\n        {\n            \"name\": \"base\",\n            \"hidden\": true,\n            \"binaryDir\": \"${sourceDir}/out/${presetName}\",\n            \"toolchainFile\": \"${sourceDir}/etc/cmake/toolchain.cmake\",\n            \"cacheVariables\": {\n                \"CMAKE_EXPORT_COMPILE_COMMANDS\": \"YES\"\n            }\n        },\n        {\n            \"name\": \"default\",\n            \"inherits\": \"base\"\n        },\n        {\n            \"name\": \"ninja\",\n            \"hidden\": true,\n            \"generator\": \"Ninja Multi-Config\"\n        },\n        {\n            \"name\": \"ninja-gcc14\",\n            \"inherits\": [\n                \"default\",\n                \"ninja\"\n            ],\n            \"environment\": {\n                \"CXX\": \"g++-14\"\n            }\n        },\n        {\n            \"name\": \"ninja-clang19-osx\",\n            \"inherits\": [\n                \"default\",\n                \"ninja\"\n            ],\n            \"environment\": {\n                \"CXX\": \"/opt/homebrew/opt/llvm@17/bin/clang++\"\n            }\n        }        \n   ]\n}\n</code></pre>","tags":["c++","make","cmake"]},{"location":"blog/2025/01/26/setting-up-a-new-c-project/#makefile","title":"Makefile","text":"<p>Make is not needed but I like it to reduce typing on common tasks. This template is my goto for just about any project irregardless of language.</p> <pre><code>ifeq ($(OS),Windows_NT)\n\tSHELL := pwsh.exe\nelse\n\tSHELL := pwsh\nendif\n\n.SHELLFLAGS := -NoProfile -Command\n\nifneq (,$(wildcard .env))\n\tinclude .env\n\texport\nendif\n\nOUT ?= out\nPRESET ?= default\nCONFIG ?= Release\n\n.PHONY: configure build test install clean\n\n$(OUT)/$(PRESET)/CMakeCache.txt: CMakeLists.txt\n\t@cmake \\\n\t\t-B $(OUT)/$(PRESET) \\\n\t\t-S . \\\n\t\t--preset $(PRESET)\n\nconfigure: $(OUT)/$(PRESET)/CMakeCache.txt\n\nbuild: configure\n\t@cmake \\\n\t\t--build $(OUT)/$(PRESET) \\\n\t\t--config $(CONFIG) \n\ntest: build\n\t@ctest \\\n\t\t--test-dir $(OUT)/$(PRESET) \\\n\t\t--build-config $(CONFIG) \\\n\t\t--output-on-failure\n\nclean:\n\t@-Remove-Item -Recurse -Force $(OUT)\n</code></pre> <p>Warning</p> <p>Makefiles must be indented with tabs, not spaces.</p> <p>I have choosen <code>powershell</code> as shell which probably isn't that common. <code>Powershell</code> has great crossplatform support so give it a try. Check out here for installation instructions but if you are using the <code>dotnet</code> eco-system you can install it with:</p> <pre><code>dotnet tool install --global PowerShell\n</code></pre>","tags":["c++","make","cmake"]},{"location":"blog/2025/01/26/setting-up-a-new-c-project/#mixing-vcpkg-with-fetchcontent","title":"Mixing Vcpkg with FetchContent","text":"<p>You can combine Vcpkg and FetchContent to manage dependencies. Using <code>FetchContent</code>:</p> <pre><code>include(FetchContent)\nFetchContent_Declare(\n    MyDependency\n    GIT_REPOSITORY https://github.com/example/mydependency.git\n    GIT_TAG main\n)\nFetchContent_MakeAvailable(MyDependency)\n\nfind_package(MyDependency CONFIG REQUIRED)\n</code></pre> <p>Ensure Vcpkg is prioritized using <code>FIND_PACKAGE_ARGS</code>:</p> <pre><code>FetchContent_Declare(\n    AnotherDependency\n    GIT_REPOSITORY https://github.com/example/anotherdependency.git\n    GIT_TAG main\n    FIND_PACKAGE_ARGS CONFIG REQUIRED\n)\nFetchContent_MakeAvailable(AnotherDependency)\n</code></pre>","tags":["c++","make","cmake"]},{"location":"blog/2025/01/26/setting-up-a-new-c-project/#consuming-libraries-from-github","title":"Consuming Libraries from GitHub","text":"<p>To consume the library from GitHub using FetchContent:</p> <pre><code>FetchContent_Declare(\n    MyLibrary\n    GIT_REPOSITORY https://github.com/example/mylibrary.git\n    GIT_TAG main\n)\nFetchContent_MakeAvailable(MyLibrary)\n</code></pre> <p>Or with Vcpkg:</p> <pre><code>vcpkg install mylibrary\n</code></pre>","tags":["c++","make","cmake"]},{"location":"blog/2025/01/26/setting-up-a-new-c-project/#conclusion","title":"Conclusion","text":"<p>This setup combines the power of modern C++20, CMake, and dependency management tools like Vcpkg and FetchContent. By mixing these approaches, you can create a flexible and efficient build system. Experiment with these methods to find what works best for your project.</p>","tags":["c++","make","cmake"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/","title":"Setting Up an Android project using Gradle without using an IDE","text":"<p>Modern Android development offers many tools to streamline setup, but understanding the build system is crucial for debugging, customizing, and scaling projects efficiently. While Android Studio provides an easy wizard to generate projects, blindly relying on it can be limiting. This article walks through the minimal manual setup of an Android project using Gradle, focusing on clarity and control over generated files. This guide provides a deeper understanding of how Gradle structures Android projects, empowering developers to make informed configuration decisions.</p>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#the-evolution-of-android-build-systems-from-ant-to-gradle","title":"The Evolution of Android Build Systems: From Ant to Gradle","text":"<p>Android development has undergone significant transformations since its inception in 2008. The tools and languages used to build Android applications have evolved to improve developer productivity, project scalability, and build performance.</p> <p>Early Days: Apache Ant and Eclipse In the early years of Android, developers primarily used Eclipse IDE with the Android Development Tools (ADT) plugin. The build system was based on Apache Ant, a tool that required XML-based configuration and offered limited flexibility.</p> <p>The Shift to Gradle and Android Studio In 2013, Android Studio was introduced as the official IDE, replacing Eclipse. Alongside it, Google adopted Gradle as the default build system, bringing:</p> <ul> <li>Declarative build scripts written in Groovy (later Kotlin).</li> <li>Dependency management via Maven repositories.</li> <li>Improved build performance with incremental compilation and parallel execution.</li> <li>Customizable build variants (e.g., debug, release, free version, pro version).</li> </ul> <p>The Adoption of Kotlin For nearly a decade, Java was the primary language for Android development. In 2017, Google officially announced Kotlin as a first-class language for Android development. In 2019, Google announced that the Kotlin programming language is the preferred language for Android developers.</p>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#prerequisites","title":"Prerequisites","text":"<p>Before setting up the project, ensure that the necessary tools are installed. This guide assumes a development environment with a Java Development Kit (JDK), Gradle, and the Android Software Development Kit (SDK).</p>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#java-development-kit-jdk","title":"Java Development Kit (JDK)","text":"<p>Android development requires a Java runtime environment. For this setup, Eclipse Temurin JDK is used, but any compatible JDK version should work. The recommended version is JDK 17, as it aligns with the requirements of modern Android projects.</p> <ul> <li>Download Eclipse Temurin JDK: https://adoptium.net/temurin/releases/</li> <li> <p>Ensure that Java is installed by running:</p> <pre><code>java -version\n</code></pre> </li> </ul> <p>This should return the installed Java version. If Java is not installed or an incorrect version is displayed, update the system path or reinstall the JDK.</p>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#gradle","title":"Gradle","text":"<p>Gradle is the build automation tool used to compile and package the Android application. While Gradle can be installed globally, this guide recommends using a project-specific Gradle wrapper, which ensures version consistency across different development environments.</p> <ul> <li>Download Gradle: https://gradle.org/install/</li> <li> <p>Verify installation by running:</p> <pre><code>gradle -v\n</code></pre> </li> <li> <p>Install the wrapper in your project folder by running:</p> <pre><code>gradle wrapper --gradle-version 8.12.1\n</code></pre> </li> </ul>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#android-sdk","title":"Android SDK","text":"<p>The Android SDK provides the necessary tools, libraries, and emulator support for developing and testing Android applications. There are two primary installation methods:</p> <ol> <li>Using Android Studio (recommended) \u2013 Android Studio includes an SDK manager for easy installation.</li> <li>Using the standalone command-line tools \u2013 If Android Studio is not required, the SDK can be installed separately.</li> </ol> <ul> <li>Download Android Studio or SDK Tools: https://developer.android.com/studio#command-tools</li> <li>After installation, verify the SDK location:<ul> <li>On macOS: <code>$HOME/Library/Android/sdk</code></li> <li>On Linux: <code>$HOME/Android/Sdk</code></li> <li>On Windows: <code>%LOCALAPPDATA%\\Android\\Sdk</code></li> </ul> </li> </ul> <p>Optionally, set the <code>ANDROID_SDK_ROOT</code> environment variable to point to the correct SDK path.</p> <p><pre><code>export ANDROID_HOME=/path/to/android/sdk\nexport PATH=$ANDROID_HOME/platform-tools:$PATH\n</code></pre> Verify that you have a connected Android device by running:</p> <pre><code>adb devices\n</code></pre>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#project-structure","title":"Project Structure","text":"<p>The folder structure for the project is organized as follows:</p> <pre><code>project-root/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 gradle.properties\n\u251c\u2500\u2500 local.properties\n\u251c\u2500\u2500 settings.gradle.kts\n\u251c\u2500\u2500 gradle\n\u2502   \u2514\u2500\u2500 libs.versions.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 androidApp\n        \u251c\u2500\u2500 build.gradle.kts\n        \u2514\u2500\u2500 src\n            \u2514\u2500\u2500 main\n                \u251c\u2500\u2500 AndroidManifest.xml\n                \u251c\u2500\u2500 kotlin\n                \u2502   \u2514\u2500\u2500 MainActivity.kt\n                \u2514\u2500\u2500 res\n                    \u251c\u2500\u2500 drawable\n                    \u2502   \u251c\u2500\u2500 ic_launcher_background.xml\n                    \u2502   \u2514\u2500\u2500 ic_launcher_foreground.xml\n                    \u251c\u2500\u2500 layout\n                    \u2502   \u2514\u2500\u2500 activity_main.xml\n                    \u251c\u2500\u2500 mipmap-anydpi-v26\n                    \u2502   \u2514\u2500\u2500 ic_launcher.xml\n                    \u2514\u2500\u2500 values\n                        \u251c\u2500\u2500 strings.xml\n                        \u2514\u2500\u2500 styles.xml\n</code></pre> <p>Information</p> <p>Android projects usually don't have modules under a <code>src</code> directory. If you preferr a more standard layout, put your modules in the root directory. Adopting a src layout aligns the project structure with other languages like dotnet, c++ and python.</p>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#top-level-files","title":"Top level files","text":"File Purpose settings.gradle.kts Defines project-level settings, including which modules should be included.        \u00a0\u00a0 gradle.properties Stores global Gradle properties, like JVM arguments, versioning, or flags. local.properties Stores local machine-specific settings, such as the Android SDK path. This file is not meant for version control. .gitignore Defines files and directories that should not be tracked by Git, such as build artifacts, .gradle/, and local.properties. gradle/libs.versions.toml \u00a0Version catalog file that centralizes dependency versions.","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#settingsgradlekts","title":"settings.gradle.kts","text":"<p>This file configures where plugins are fetched from, where dependencies are fetched from and finally includes all modules that make up this project.</p> <pre><code>pluginManagement {\n    repositories {\n        gradlePluginPortal()\n        google()\n        mavenCentral()\n    }\n}\n\ndependencyResolutionManagement {\n  repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n  repositories {\n      google()\n      mavenCentral()\n  }\n}\n\nrootProject.name = \"&lt;PROJECT NAME&gt;\"\n\ninclude(\":src:androidApp\")\n</code></pre>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#gradleproperties","title":"gradle.properties","text":"<p>This file declares global properties that can later be accessed in your build scripts as <code>project.properties[\"NAME\"]</code>. I just use it to enable AndroidX which is a more modern support library for Android.</p> <pre><code>android.useAndroidX=true\n</code></pre>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#localproperties","title":"local.properties","text":"<p>This optional file declares settings for the current user. This file should not be checked into version control.</p> <pre><code>sdk.dir=/path/to/Library/Android/sdk\n</code></pre> <p>You can also set the environment variable <code>ANDROID_SDK_ROOT</code>.</p>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#libsversionstoml","title":"libs.versions.toml","text":"<p>The libs.versions.toml file centralizes dependency versions, ensuring consistency across different modules. Unlike manually defining versions inside build.gradle.kts, this method reduces redundancy and makes dependency upgrades easier.</p> <pre><code>[versions]\nandroid-compileSdk = \"35\"\nandroid-minSdk = \"24\"\nandroid-targetSdk = \"35\"\n\n[libraries]\ngoogle-material = { group = \"com.google.android.material\", name = \"material\", version = \"1.12.0\" }\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version = \"8.8.0\" }\nkotlin-android = {\u00a0id = \"org.jetbrains.kotlin.android\", version = \"2.1.10\" }\n</code></pre> <p>The contents of this file is referenced in other parts of the build. For instance, the version fields are used when setting up the android build.</p> <pre><code>minSdk = libs.versions.android.minSdk.get().toInt()\ntargetSdk = libs.versions.android.targetSdk.get().toInt()\n</code></pre> <p>This ensures that we use the same SDK values throughout the build.</p> <p>Libraries are imported in the modules like this:</p> <pre><code>implementation(libs.google.material)\n</code></pre> <p>As you can see, dashes are normalized into dots. </p> <p>It is also possible to reference versions directly.</p> <pre><code>[versions]\nmaterial-version = \"1.12.0\"\n\n[libraries]\ngoogle-material = { group = \"com.google.android.material\", name = \"material\", version.ref = \"material-version\" }\n</code></pre> <p>prefer avoiding extra indirection, even if it means updating a few duplicate versions manually.</p>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#android-module-files","title":"Android module files","text":"File Purpose build.gradle.kts The main Gradle build script for the root project. It may define dependencies, repositories, or global Gradle settings. kotlin/MainActivity.kt The entry point of the Android app. This is the main activity that gets launched. res/drawable/ Stores imageassets (icons, backgrounds, etc.). res/layout/activity_main.xml Defines the UI layout for MainActivity. res/values/strings.xml Stores app text values (e.g., \"Welcome to Trailmaker\"). res/values/styles.xml Defines themes and styles for UI elements. <p>Modules are defined under the <code>src</code> directory. Each module is included in the top level <code>settings.gradle.kts</code> using an <code>include</code> statement.</p>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#android-module","title":"Android module","text":"<p>I tend to organize my modules under a <code>src</code> folder to keep things similar across different types of projects. This might not be the most common so if you prefer, put your modules in the root folder and adjust the includes accordingly.</p>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#buildsettingskts","title":"build.settings.kts","text":"<pre><code>plugins {\n    alias(libs.plugins.android.application)\n    alias(libs.plugins.kotlin.android)\n}\n\nkotlin {\n\n    jvmToolchain(17)\n\n    sourceSets {\n        main {\n            dependencies {\n                implementation(libs.google.material)\n            }\n        }\n    }\n}\n\nandroid {\n    namespace = \"&lt;namespace&gt;\"\n    compileSdk = libs.versions.android.compileSdk.get().toInt()\n\n    buildFeatures {\n        buildConfig = true\n    }\n\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_17\n        targetCompatibility = JavaVersion.VERSION_17\n    }\n\n    defaultConfig {\n        applicationId = \"&lt;application id&gt;\"\n        minSdk = libs.versions.android.minSdk.get().toInt()\n        targetSdk = libs.versions.android.targetSdk.get().toInt()\n        versionCode = 1\n        versionName = \"1.0\"\n    }\n}\n</code></pre>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#androidmanifestxml","title":"AndroidManifest.xml","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n\n    &lt;application\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"Demo App\"\n        android:theme=\"@style/AppTheme\"\n    &gt;\n\n        &lt;activity\n            android:name=\".MainActivity\"\n            android:exported=\"false\"\n            android:launchMode=\"singleTop\"\n        &gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n    &lt;/application&gt;\n\n&lt;/manifest&gt;\n</code></pre> <p><code>&lt;application&gt;</code> element <pre><code>&lt;application\n    android:icon=\"@mipmap/ic_launcher\"\n    android:label=\"Demo App\"\n    android:theme=\"@style/AppTheme\"\n&gt;\n</code></pre></p> <p>Defines the application-level settings. The attributes:</p> <ul> <li>android:icon=\"@mipmap/ic_launcher\": Specifies the app\u2019s launcher icon, located in the mipmap folder.</li> <li>android:label=\"Demo App\": Sets the app\u2019s name displayed to users.</li> <li>android:theme=\"@style/AppTheme\": Applies a theme to the application, typically defined in res/values/styles.xml.</li> </ul> <p><code>&lt;activity&gt;</code> element</p> <pre><code>&lt;activity\n    android:name=\".MainActivity\"\n    android:exported=\"false\"\n    android:launchMode=\"singleTop\"\n&gt;\n</code></pre> <p>Defines an activity in the application.</p> <ul> <li>android:name=\".MainActivity\": The name of the activity. Since it starts with . (dot), it refers to com.yourpackage.MainActivity. It gets it's default value from <code>android.namespace</code> defined in <code>build.settings.kts</code>. It is entirely possible to name the MainActivity class something else.</li> <li>android:exported=\"false\": Disallows the activity to be launched by external apps or system components.</li> <li>android:launchMode=\"singleTop\": Ensures that if the activity is already at the top of the stack, a new instance is not created. Instead, onNewIntent() is called.</li> </ul> <p><code>&lt;intent-filter&gt;</code> element</p> <p><pre><code>&lt;intent-filter&gt;\n    &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n    &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n&lt;/intent-filter&gt;\n</code></pre> Defines how this activity can be launched.</p> <ul> <li>android.intent.action.MAIN: This makes MainActivity the entry point of the app.</li> <li>android.intent.category.LAUNCHER: Specifies that this activity should be shown in the launcher screen (app drawer).</li> </ul>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#mainactivitykt","title":"MainActivity.kt","text":"<pre><code>package &lt;namespace&gt;\n\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\n\nfinal class MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}\n</code></pre>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#activity_mainxml","title":"activity_main.xml","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;androidx.constraintlayout.widget.ConstraintLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\"&gt;\n\n&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;\n</code></pre>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#stringsxml","title":"strings.xml","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;resources&gt;\n    &lt;string name=\"someName\"&gt;some string&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#stylesxml","title":"styles.xml","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;resources&gt;\n    &lt;style name=\"AppTheme\" parent=\"Theme.MaterialComponents.DayNight.NoActionBar\"&gt;\n    &lt;/style&gt;\n&lt;/resources&gt;\n</code></pre>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#application-icon-setup","title":"Application Icon Setup","text":"<p>In modern Android development, adaptive icons provide flexibility across different screen sizes and launcher designs. Instead of using multiple rasterized image files, adaptive icons use two layers:</p> <p>Foreground layer (ic_launcher_foreground.xml) \u2013 Contains the primary icon content. Background layer (ic_launcher_background.xml) \u2013 Defines the background shape or color. Icon definition (ic_launcher.xml) \u2013 Declares the adaptive icon setup.</p>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#building-and-running-your-application","title":"Building and running your application","text":"<p>With the project set up, you can now build and run your Android application using Gradle.</p>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#building-the-apk","title":"Building the APK","text":"<p>To compile the project and generate an APK, run the following command:</p> <pre><code>./gradlew assembleDebug\n</code></pre> <p>This will produce an APK in the src/androidApp/build/outputs/apk/debug/ directory. If you need a release build, use:</p> <pre><code>./gradlew assembleRelease\n</code></pre> <p>For release builds, ensure you have a signing configuration set up in your build.gradle.kts.</p>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#installing-and-running-on-a-device","title":"Installing and Running on a Device","text":"<p>Once the APK is built, you can install it on a connected device or emulator:</p> <pre><code>./gradlew installDebug\n</code></pre> <p>This automatically installs the debug APK onto a device. If multiple devices or emulators are connected, specify the target device using:</p> <pre><code>adb -s &lt;device_id&gt; install src/androidApp/build/outputs/apk/debug/androidApp-debug.apk\n</code></pre> <p>You can launch the app manually from the device or via:</p> <pre><code>adb shell am start -n &lt;your.package.name&gt;/.MainActivity\n</code></pre> <p>Running in an Emulator If you\u2019re testing on an emulator, ensure you have an AVD (Android Virtual Device) set up:</p> <pre><code>emulator -avd &lt;AVD_NAME&gt;\n</code></pre> <p>If you don\u2019t have an AVD configured, create one using:</p> <pre><code>avdmanager create avd -n myEmulator -k \"system-images;android-35;google_apis;x86_64\"\n</code></pre> <p>Once the emulator is running, you can install and launch the app as described above.</p>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#cleaning","title":"Cleaning","text":"<p>To ensure a fresh build, clear any cached outputs before rebuilding:</p> <p>./gradlew clean</p>","tags":["kotlin","gradle","android"]},{"location":"blog/2025/02/02/setting-up-a-new-android-project-using-gradle/#conclusion","title":"Conclusion","text":"<p>Wizards provide a lot of benefits when quickly trying something out, but as I have shown here, the machinery behind building an Android app is quite manageable by hand and increases the understanding of the build system.</p>","tags":["kotlin","gradle","android"]},{"location":"blog/archive/2025/","title":"2025","text":""}]}